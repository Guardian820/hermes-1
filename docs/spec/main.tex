\documentclass[journal]{IEEEtran}

\begin{document}
\title{Encrypted Distributed Data Storage\\with Regenerative Blocks}

\author{
        Matthew~Olan, %~\IEEEmembership{Member,~IEEE,}
        John-Alan~Simmons,
        and~William~Mak
}

%\markboth{Journal of \LaTeX\ Class Files,~Vol.~6, No.~1, January~2013}{Olan \MakeLowercase{\textit{et al.}}: Bare Demo of IEEEtran.cls for Journals}

% make the title area
\maketitle

\begin{abstract} % Lots taken from Bitcoin documentation, to be modified
A purely peer-to-peer data storage network would allow data to be distributed across multiple parties, without the requirement of a dedicated server. Current solutions exist for file sharing and local cloud storage, but fail to provide secure storage for sensitive data while using the potential power of the Internet or other large networks of computers. Distributed hash tables, used in current file networks, provide part of the solution but, on its own, falls short if a unknown third party is introduced. Further, there is no control over when a connected node will leave the network, effectively destroying the data stored on it. The proposed solution to these issues uses the Advanced Encryption Standard (AES) and forward error correction (FEC), along with the Hermes network model. A network wide manifest of data transactions is generated by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they'll generate the longest chain and outpace attackers. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone.
\end{abstract}

\IEEEpeerreviewmaketitle

\section{Introduction}
\IEEEPARstart{L}{orem} ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?


\section{Non-Network Dependent System}
Data to be inserted into the network must first undergo a multistage encoding process to ensure its security and integrity. We define the client-side of the implementation to be anything that must first be executed before contacting peers on the rest of the network. These stages are in order of optimal execution. Out of order execution may cause unknown or unusable results. We define the *source data* to be the data inputted by the user in its original state to be sent to the network.

\subsection{Source File Compression}
Compression is Lempel-Ziv-Markov Chain Algorithm (LZMA), an advanced version of the LZ77 standard (RFC 1951). This was chosen for its high compression ratio to time. Since LZMA can be decompressed regardless of the level of compression, these settings are arbitrary, but for the purposes of space over time, is usually set to the highest level of compression.

\subsection{Source File Encryption}
Encryption is Advanced Encryption Standard with Cipher-Block Chaining (AES-CBC). This mode of AES works such that,

\begin{center}
$C_i = E_k(P_i \oplus{} C_{i-1})$, $C_0 = IV$\\
$￼P_i = D_k(C_i) \oplus{} C_{i-1}$, $C_0 = IV$\\
\end{center}

where $C$ is the cipher-text, $P$ is the plain-text, and $k$ is the key which will be defined later. ￼This is to prevent data blocks from being independently decrypted with malicious intent. This also does not allow for partial decryption of user data, so if even a single data block is lost, none of the original data can be recovered. This problem will be addressed by Fountain Codes in section 1.5.

\subsection{Dynamic Source File Partitioning}
The source file is partitions into chunks such that,

\begin{center}
$C_i = S_{(i \times{} size)} ... S_{((i + 1) \times{} size)}$, $0 \le i \le \lceil{\frac{\left\vert{S}\right\vert}{size}}\rceil$ \\
\end{center}

This causes and issue if length(source) mod size $\neq 0$. To resolve this, padding is used loosely following ISO/IEC 7816-4. User data is followed by a byte valued ‘01’, followed by zero bytes. Padding is always used to ensure user data following the same pattern does not get truncated.

\subsection{Fountain Codes}
... uses a PRNG (1.5) so that manifests do not need to be used.

\subsection{Pseudo-random Number Generators}
degree of distribution, d, is dictated by the network (2.2)... number of chunks in a block, n, is $1 \le n \le d$
number of blocks is such that the combined number of bytes is $\le$ original number of bytes in source file\
Parents: $x_i \in P_i \iff x_i \notin P_{i-1}$

\subsection{Block Nomenclature}
The resulting blocks from the fountain code algorithm are named such that,

\begin{center}
$N_i = H(N_{i-1}), N_0 = H(B)$\\
\end{center}

For the sake of checking file validity the first 32bytes of a block are a SHA256 checksum of the file such that,

\begin{center}
$h_i = H(b_i + S)$\\
\end{center}

\section{Network Dependent System}
Once the data has been processed by the client-side, it is then inserted into the network.

\subsection{Peer Discovery}
Multiple methods for peer discovery are used for different client connection capabilities. 

Local peer discovery. All peers inside local network are discovered by sending broadcast packets. If there are peers with the same secret they respond to the broadcast message and connect.

Peer exchange (PEX). When two peers are connected, they exchange information about other peers they know.
Known hosts (folder settings). If you have a known host with a static ip:port, you can specify this in Sync client, so that it connects to the peer using this information.

DHT. Sync uses DHT to distribute information about itself and obtain the information about other peers with this secret. Sync sends SHA1(Secret):ip:port to DHT to announce itself and will get a list of peers by asking DHT for the following key SHA1(Secret)

BitTorrent tracker. BitTorrent Sync can use a specific tracker server to facilitate peer discovery. The tracker server sees the combination of SHA1(secret):ip:port and helps peers connect directly. The BitTorrent Sync tracker also acts like a STUN server and can help do a NAT traversal for peers so that they can establish a direct connection even behind a NAT.

We recommend that you use a tracker server instead of DHT for reasons of faster response and NAT traversal, so peers have a higher probability of networking directly.

% \subsection{Network Coding}

% \subsection{Degree of distribution}

% \subsection{Distributed networks and DHTs}

% \subsection{Network algorithms (EMAs, ...)}

\section{Conclusion}
The conclusion goes here.


\appendices
\section{Proof of the First Zonklar Equation}
Appendix one text goes here.

\section{}
Appendix two text goes here.

\section*{Acknowledgment}

The authors would like to thank Gray Graffam for supporting the development of the project in so many ways.


% Can use something like this to put references on a page
% by themselves when using endfloat and the captionsoff option.
\ifCLASSOPTIONcaptionsoff
  \newpage
\fi

\begin{thebibliography}{1}

\bibitem{IEEEhowto:kopka}
H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed.\hskip 1em plus
  0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

%http://www.bms.bc.ca/resources/library/pdf/GuidelinesScientificPapers.pdf
%http://www.inference.phy.cam.ac.uk/oghm2/files/fountain-draft.pdf
%http://tools.ietf.org/html/rfc6330

\end{thebibliography}

\end{document}


